1、Vue 生命周期方法有哪些

* `beforeCreate` ： 实例初始化前
* `created`：实例创建完成，此时实例已完成以下配置：**数据观测**，**属性和方法运算**，**watch/event 事件回调**
* `beforeMount`：在挂载开始之前被调用，相关的`render`函数首次被调用
* `mounted`：在挂载完成后发生，真实的 DOM 挂载完毕，**数据完成双向绑定，可以访问到 DOM 节点**
* `beforeUpdate`：数据更新时调用，发生在虚拟 DOM 重新渲染和打补丁（patch）之前.可以在这个钩子中进一步更改状态，这不会触发附加的重渲染过程
* `updated`：发生在更新完成之后，当前阶段组件 DOM 已完成更新。要注意的是避免在此期间更改数据，因为这可能会导致无限循环的更新，**该钩子在服务器端渲染期间不被调用**。
* `beforeDestroy`：实例销毁之前调用。在这一步，实例仍然完全可用。
* `destroyed`：Vue 实例销毁后调用。调用后，Vue 实例指示的所有东西都会解绑定，所有的事件监听器会被移除，所有的子实例也会被销毁。**该钩子在服务器端渲染期间不被调用**。
* `actived`：`keep-alive` 专属，组件被激活时调用
* `deactivated`：`keep-alive` 专属，组件被销毁时调用

异步请求在哪一步发起？

可以在构子函数`created`、`beforeMount`、`mounted`中进行异步请求，因为在这三个构子函数中，data 已经创建，可以将服务器返回的数据进行赋值。

如果异步请求不需要依赖 Dom 推荐在 created 钩子函数中调用异步请求，因为在 created 钩子函数中调用异步请求有以下优点：

- 能更快获取到服务端数据，减少页面 loading 时间；
- ssr  不支持 `beforeMount` 、`mounted` 钩子函数，所以放在 `created` 中有助于一致性；



2、怎样理解 Vue 的单向数据流

数据总是从从父组件传到子组件，并且子组件没有权利修改父组件传递过来的数据。

> 在子组件直接用 v-model 绑定父组件传过来的 prop 这样是不规范的写法 开发环境会报警告



3、虚拟 DOM 是什么，有什么优缺点

> 由于在浏览器中操作 DOM 对于浏览器来说会很影响性能。这就是虚拟 DOM 产生的原因

什么是虚拟 DOM 

* 虚拟 DOM 本质就是用一个原生的 JS 对象去描述一个 DOM 节点，是对真实 DOM 的一层抽象

优点：

* 使用虚拟 DOM 操作保证在你不需要手动优化的情况下，可以提供一个不错的性能。
* 无需手动操作 DOM ，只要写好 `view-model` 的代码逻辑即可
* 跨平台：虚拟 DOM  本质上是 JS 对象，因此虚拟DOM 可以跨平台操作，比如 SSR（服务端渲染）、weex开发等

缺点：

* **首次渲染时加载时长过长**，因为多了一层虚拟 DOM 的计算，会比 innerHTML 插入慢



4、`v-for`为什么要加 `key`

在 Vue 项目中 `key`是虚拟DOM 的唯一标记，通过这个 `key` 我们的 `diff` 操作可以更加准确，更加快速。



5、`vue-router`路由构子函数是什么

* 全局守卫，
  * beforeEach         前置路由守卫
  * beforeResolve   解析路由守卫(异步)    
  * afterEach            后置路由守卫(没有next函数)                                                         

* 组件守卫

  * beforeRouteEnter     访问该组件之前守卫               
  * beforeRouteUpdate  路由变化之前守卫     
  * beforeRouteLeave     离开当前组件之前守卫（不是关闭离开页面）   

* 路由守卫

  * beforeRouteEnter

  

6、Vuex 页面刷新数据丢失怎么解决

* 在刷新前将数据保存到本地缓存中，结束后再将其保存到 VueX 中
* 使用 vuex-persist 插件，它就是为 Vuex 持久化存储而生的一个插件。不需要你手动存取 storage ，而是直接将状态保存至 cookie 或者 localStorage 中



7、Vuex 为什么要分模块并且加命名空间

由于使用`单一状态树`，应用的所有状态会集中到一个比较大的对象，当应用变得非常复杂时，`store`对像就有可能变得相当臃肿。

Vuex 允许我们将 `store`分割成模块`module`，每一个模块拥有自己的 state、mutation、action、getter、甚至是嵌套子模块。



8、什么是 SSR 

`SSR` 就是服务端渲染（在服务端将 Vue 直接渲染成 HTML 后直接返回给客户端）

优点：

* SSR 有着更好的 SEO、并且首屏加载速度更快

缺点：

* 开发条件受到限制，服务端渲染只支持 `beforeCreate`和 `created`俩个钩子.并且服务端渲染也需要处于 Node.js 的运行环境



9、vue 中使用了那些设计模式

* 工厂模式 （传入参数即可创建实例）

* 单例模式 （整个程序有且仅有一个实例）

* 发布-订阅模式 (vue 事件机制)

* 观察者模式 (响应式数据原理)

* 装饰模式: (@装饰器的用法)

* 策略模式 策略模式指对象有某个行为,但是在不同的场景中,该行为有不同的实现方案-比如选项的合并策略

  

10、 Vue 的性能优化

* `v-if` 和 `v-show`要分场合使用
* v-for 遍历必须加 key，key 最好是 id 值，且避免同时使用 v-if

* 图片懒加载
* 路由懒加载
* 使用第三方插件时按需引入
* 使用服务端渲染 或 预渲染
* 适当采用 `keep-alive` 缓存组件