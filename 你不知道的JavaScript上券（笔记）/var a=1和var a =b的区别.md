#### 引擎，编译器，作用域

* 引擎： &nbsp;&nbsp;**负责整个Javascript程序的编译及执行过程**。
* 编译器：**负责语法分析及代码生成**。
* 作用域：**负责收集并维护有所有声明的标识符组成的一系列查询**。

#### 编译器(编译过程var a=1;)

  * 第一步：编译器首先会将这段代码分解成**词法单元**，然后将词法单元解析成**树结构**。
  * 第二步：对词法单元进行解析，解析到var a时，编译器会询问**作用域是否存在一个变量名为a在同一作用域的集合中**。如果有，编译器就忽略此声明。反之，在要求的作用域下声明变量。
  * 第三步：**生成可以运行代码**(=1)给引擎执行，生成代码的这个过程就涉及到LHS和RHS(具体细节看第三节)的俩种赋值概念。
  * 第四步：引擎运行编译器生成的代码时，会询问**作用域是否存在在当前作用域下变量名为a的集合**，如果没有，则在向上一级作用域查找变量名a(具体细节看第四节)。如果有，引擎则对变量名为a的集合赋值。

 #### LHS和RHS

 什么是LHS、RHS

 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; LHS:**赋值操作的目标是谁。**
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;RHS:**谁是赋值操作的源头**。

上面的解释是我通过其他途径了解到的，我自己也不是很明白。按我自己的理解：**LHS就是正常的变量赋值(a=1)，RHS就是通过第三方来赋值的(a=b，b=2)**。

举例：

```javascript
function foo(a){
    console.log(a);
}
var b=2
foo(b);
```

程序调用foo() 方法：

* 步骤一：因为函数需要传参，故先对foo()进行RHS赋值
* 步骤二：对形参a进行LHS赋值(a=2)
* 步骤三：对console进行RHS赋值
* 步骤四：对参数a进行LHS赋值(a=2)
* 注意：**每次程序执行(引擎)访问变量或函数时，都会去询问作用域该变量或函数是否存在。如果不存在则可能会向上查找，或者抛异常**(第五小节)。

 ##### &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  区分LHS、RHS的重要性

   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(1)如果是LHS赋值，在顶级作用域(全局)找不到改变量，则全局作用域下，会隐式创建一个具有该名称的变量，并将其返还给引擎(非严格模式下)

```javascript
   function foo(){
      a=2;
  }
  //a为定义，此时全局创建一个名为a的变量集合
```

  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(2)如果是RHS赋值，在所有嵌套的作用域下遍寻不到该所需的变量，则**抛出异常ReferenceError**


```javascript
function foo(){
  var a=b;
}
//a为定义，此时会抛ReferenceError
```

但在ES5中对于这个弊端，也给出了规定。(具体看第五小节)

 #### 引擎寻找变量

 * 当引擎在当前作用域找不到变量名为a的集合时，会**向外层嵌套的作用域进行查找**，**直到找到该变量为止，或抵达最外层的作用域(也就是全局作用域)为止**。
 * 在ES6中，对这个弊端，也得到了解决。[具体可以点击这里](https://blog.csdn.net/weixin_44659458/article/details/108565703)

 #### 异常

*  在ES5中引入了“严格模式”，**严格禁止自动或隐式地创建全局变量**。
*  在严格模式中**LHS查询失败时**，并不会创建并返回一个全局变量，引擎会抛出同查询失败时类似的**ReferenceError异常**。
*  对于**RHS赋值**，如果查询找到一个变量，但是如果你尝试对这个变量进行不合理操作，比如对一个非函数类型的值进行函数调用，或者引用null,underfined类型的值中的操作，那么引擎会抛出另外一个异常，叫做**TypeError**。
*  总结：**在严格模式下，抛出异常ReferenceError则同作用域判别失败相关，而TypeError则代表作用域判别成功了，但是对结果的操作是不合法的**。

